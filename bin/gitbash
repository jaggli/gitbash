#!/usr/bin/env bash
# gitbash - Interactive git utilities for bash with fzf-powered menus

set -euo pipefail

CONFIG_FILE="$HOME/.gitbashrc"

load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$CONFIG_FILE"
    fi
}

configure_gitbash() {
    load_config

    local current_prefix="${GITBASH_FEATURE_BRANCH_PREFIX:-feature/}"
    local current_merge="${GITBASH_MERGE_COMMAND:-fork}"

    echo "Configure gitbash (writes to $CONFIG_FILE)"

    local input prefix merge_cmd

    read -e -p "Feature branch prefix (used by create) [${current_prefix}]: " input
    prefix=${input:-$current_prefix}

    read -e -p "Merge tool command (used by update on conflicts) [${current_merge}]: " input
    merge_cmd=${input:-$current_merge}

    cat > "$CONFIG_FILE" <<EOF
# gitbash configuration
# Prefix for feature branches created by 'create'
GITBASH_FEATURE_BRANCH_PREFIX="$prefix"
# Merge tool command invoked by 'update' when conflicts occur
GITBASH_MERGE_COMMAND="$merge_cmd"
EOF

    echo "Saved configuration to $CONFIG_FILE"
}

# Resolve symlinks to get the actual script location
SOURCE="${BASH_SOURCE[0]}"
while [[ -L "$SOURCE" ]]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ "$SOURCE" != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")/.." && pwd)"

COMMANDS_DIR="$SCRIPT_DIR/commands"
VERSION="$(grep -o '"version": *"[^"]*"' "$SCRIPT_DIR/package.json" | cut -d'"' -f4)"

# Available commands
COMMANDS=(
    "branch"
    "cleanstash"
    "cleanup"
    "commit"
    "commits"
    "create"
    "pr"
    "stale"
    "stash"
    "stashes"
    "status"
    "switch"
    "unstash"
    "update"
)

show_help() {
    cat << 'EOF'
gitbash - Interactive git utilities for bash

Usage:
    gitbash <command> [args...]
    gitbash --help
    gitbash --init
    gitbash --config

Commands:
  branch      Interactive menu for branch operations
  cleanstash  Delete stashes (multi-select)
  cleanup     Find and delete leftover local branches
  commit      Commit with optional push
  commits     List recent commits with revert option
  create      Create feature branch with Jira parsing
  pr          Open PR in browser
  stale       List stale remote branches
  stash       Create named stash
  stashes     Interactive stash menu
  status      Interactive staging with fzf
  switch      Switch branches with fzf
  unstash     Apply stash with fzf picker
  update      Merge latest main/master into current branch

Options:
  -h, --help     Show this help message
  -v, --version  Show version number
  --init         Print shell initialization code (for sourcing)
    --config       Configure gitbash and save to ~/.gitbashrc

Examples:
  gitbash commit fix bug -p     # Commit and push
  gitbash switch feature        # Switch to branch containing "feature"
  gitbash create PROJ-123 fix   # Create feature/PROJ-123-fix

Shell Integration:
  Add to your .bashrc or .bash_profile:
    eval "$(gitbash --init)"

  This enables calling commands directly:
    commit fix bug -p
    switch feature

Dependencies:
  brew install fzf           # Required
  brew install git-delta     # Optional: better diffs
  brew install bat           # Optional: syntax highlighting
EOF
}

show_init() {
    cat << EOF
# gitbash shell integration
# Add this to your .bashrc or .bash_profile:
#   eval "\$(gitbash --init)"

GITBASH_COMMANDS_DIR="$COMMANDS_DIR"

EOF
    # Output source commands for each script
    for cmd in "${COMMANDS[@]}"; do
        if [[ -f "$COMMANDS_DIR/$cmd.sh" ]]; then
            echo "source \"\$GITBASH_COMMANDS_DIR/$cmd.sh\""
        fi
    done
}

# Main entry point
main() {
    load_config
    case "${1:-}" in
        -h|--help|"")
            show_help
            exit 0
            ;;
        -v|--version)
            echo "gitbash $VERSION"
            exit 0
            ;;
        --init)
            show_init
            exit 0
            ;;
        --config)
            configure_gitbash
            exit 0
            ;;
        *)
            local cmd="$1"
            shift
            
            # Check if command exists
            if [[ -f "$COMMANDS_DIR/$cmd.sh" ]]; then
                # Source the command file and execute the function
                source "$COMMANDS_DIR/$cmd.sh"
                "$cmd" "$@"
            else
                echo "Error: Unknown command '$cmd'" >&2
                echo "Run 'gitbash --help' for available commands." >&2
                exit 1
            fi
            ;;
    esac
}

main "$@"


