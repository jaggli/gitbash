#!/usr/bin/env bash
# gitbash - Interactive git utilities for bash with fzf-powered menus

set -euo pipefail

CONFIG_FILE="$HOME/.gitbashrc"

load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$CONFIG_FILE"
    fi
}

configure_gitbash() {
    load_config

    # Backward compatibility: migrate GITBASH_FEATURE_BRANCH_PREFIX to GITBASH_CREATE_BRANCH_PREFIX
    local current_prefix="${GITBASH_CREATE_BRANCH_PREFIX:-}"
    if [[ -z "$current_prefix" && -n "${GITBASH_FEATURE_BRANCH_PREFIX:-}" ]]; then
        # Remove "feature/" prefix from old variable
        current_prefix="${GITBASH_FEATURE_BRANCH_PREFIX#feature/}"
    fi
    # Remove trailing slash if present
    current_prefix="${current_prefix%/}"
    # Default to empty if still not set
    current_prefix="${current_prefix:-}"
    
    local current_merge="${GITBASH_MERGE_COMMAND:-fork}"
    local current_theme="${GITBASH_THEME:-auto}"
    local current_stale_months="${GITBASH_STALE_MONTHS:-3}"
    local current_cleanup_days="${GITBASH_CLEANUP_DAYS:-7}"
    local current_no_issue_parsing="${GITBASH_CREATE_NO_ISSUE_PARSING:-no}"
    local current_issue_fallback="${GITBASH_CREATE_ISSUE_PARSING_FALLBACK:-NOISSUE}"

    echo "Configure gitbash (writes to $CONFIG_FILE)"
    echo

    local input prefix merge_cmd theme stale_months cleanup_days no_issue_parsing issue_fallback

    # Branch prefix
    echo "Branch prefix"
    echo "Team names are typically used to organize branches by team or subproject."
    echo "Inserted between type and branch name, examples:"
    echo "  ''             → feature/PROJ-123-fix-bug"
    echo "  'team'         → feature/team/PROJ-123-fix-bug"
    echo "  'awesome-team' → hotfix/awesome-team/PROJ-999-critical-fix"
    if [[ -n "$current_prefix" ]]; then
        echo "Tip: Enter a single dash '-' to explicitly clear the prefix"
    fi
    read -e -p "Branch prefix [${current_prefix}]: " prefix
    # If user just pressed Enter, keep current value
    # If user entered a single dash, clear it
    if [[ -z "$prefix" ]]; then
        prefix="$current_prefix"
    elif [[ "$prefix" == "-" ]]; then
        prefix=""
    fi
    # Remove trailing slash if present (will be added automatically)
    prefix="${prefix%/}"

    # Merge tool
    echo
    read -e -p "Merge tool command (used by update on conflicts) [${current_merge}]: " input
    merge_cmd=${input:-$current_merge}

    # Issue parsing
    echo
    # Invert current value for display (no_issue_parsing="no" means enabled=yes)
    local current_enabled="yes"
    if [[ "$current_no_issue_parsing" == "yes" ]]; then
        current_enabled="no"
    fi
    
    read -e -p "Enable Jira issue parsing in branch names? (yes/no) [${current_enabled}]: " input
    local enable_parsing=${input:-$current_enabled}
    
    # Convert answer to no_issue_parsing variable (inverted logic)
    case "$enable_parsing" in
        yes)
            no_issue_parsing="no"
            ;;
        no)
            no_issue_parsing="yes"
            ;;
        *)
            echo "Invalid value. Using 'yes' (parsing enabled)."
            no_issue_parsing="no"
            ;;
    esac

    # Issue parsing fallback (only ask if parsing is enabled)
    if [[ "$enable_parsing" == "yes" ]]; then
        read -e -p "Fallback prefix when no issue number is provided [${current_issue_fallback}]: " input
        issue_fallback=${input:-$current_issue_fallback}
    else
        issue_fallback="${current_issue_fallback}"
    fi

    # Theme preference
    echo
    echo "Theme preference for delta/bat (affects diff highlighting):"
    echo "  auto  - Use terminal's theme detection"
    echo "  dark  - Force dark theme"
    echo "  light - Force light theme (GitHub style)"
    read -e -p "Theme [${current_theme}]: " input
    theme=${input:-$current_theme}
    case "$theme" in
        auto|dark|light) ;;
        *) 
            echo "Invalid theme. Using 'auto'."
            theme="auto"
            ;;
    esac

    # Stale branch threshold
    echo
    read -e -p "Stale branch threshold in months (used by stale) [${current_stale_months}]: " input
    stale_months=${input:-$current_stale_months}
    if ! [[ "$stale_months" =~ ^[0-9]+$ ]] || [[ "$stale_months" -lt 1 ]]; then
        echo "Invalid value. Using default of 3 months."
        stale_months=3
    fi

    # Cleanup threshold
    read -e -p "Cleanup threshold in days (used by cleanup) [${current_cleanup_days}]: " input
    cleanup_days=${input:-$current_cleanup_days}
    if ! [[ "$cleanup_days" =~ ^[0-9]+$ ]] || [[ "$cleanup_days" -lt 1 ]]; then
        echo "Invalid value. Using default of 7 days."
        cleanup_days=7
    fi

    cat > "$CONFIG_FILE" <<EOF
# Automatically generated gitbash configuration

# CAUTION: Do not edit this file manually to avoid setting being overwritten.
# run 'gitbash --config' to update settings

# Branch prefix inserted between type and issue (e.g., 'team-name' or '')
# No trailing slash needed - it's added automatically
# Format: <type>/<prefix>/<issue>-<title> or <type>/<prefix>/<title>
GITBASH_CREATE_BRANCH_PREFIX="$prefix"

# Merge tool command invoked by 'update' when conflicts occur
GITBASH_MERGE_COMMAND="$merge_cmd"

# Disable Jira issue number parsing in branch names (yes/no)
GITBASH_CREATE_NO_ISSUE_PARSING="$no_issue_parsing"

# Fallback prefix when no issue number is provided (only used if parsing is enabled)
GITBASH_CREATE_ISSUE_PARSING_FALLBACK="$issue_fallback"

# Theme for delta/bat: auto, dark, or light
GITBASH_THEME="$theme"

# Stale branch threshold in months (branches older than this in 'stale')
GITBASH_STALE_MONTHS="$stale_months"

# Cleanup threshold in days (branches merged more than this many days ago)
GITBASH_CLEANUP_DAYS="$cleanup_days"

EOF

    echo
    echo "Saved configuration to $CONFIG_FILE"

    # Check for dependencies
    check_dependencies

    # Check for shell integration
    check_shell_integration
}

# Check and offer to install dependencies
check_dependencies() {
    local missing_required=()
    local missing_optional=()

    # Optional dependencies (fzf is optional; commands will try to run without it)
    if ! command -v fzf >/dev/null 2>&1; then
        missing_optional+=("fzf")
    fi

    # Optional dependencies
    if ! command -v delta >/dev/null 2>&1; then
        missing_optional+=("git-delta")
    fi
    if ! command -v bat >/dev/null 2>&1; then
        missing_optional+=("bat")
    fi

    # If nothing missing, we're done
    if [[ ${#missing_required[@]} -eq 0 && ${#missing_optional[@]} -eq 0 ]]; then
        echo
        echo "All dependencies installed ✓"
        return 0
    fi

    echo
    echo "Dependencies:"

    # Show status of each dependency
    if command -v fzf >/dev/null 2>&1; then
        echo "  ✓ fzf (optional)"
    else
        echo "  ✗ fzf (optional) - fuzzy finder for interactive selection"
    fi

    if command -v delta >/dev/null 2>&1; then
        echo "  ✓ git-delta (optional)"
    else
        echo "  ✗ git-delta (optional) - better diff highlighting"
    fi

    if command -v bat >/dev/null 2>&1; then
        echo "  ✓ bat (optional)"
    else
        echo "  ✗ bat (optional) - syntax highlighting for file previews"
    fi

    # Build list of all missing dependencies
    local all_missing=()
    [[ ${#missing_required[@]} -gt 0 ]] && all_missing+=("${missing_required[@]}")
    [[ ${#missing_optional[@]} -gt 0 ]] && all_missing+=("${missing_optional[@]}")

    # If nothing to install, we're done
    if [[ ${#all_missing[@]} -eq 0 ]]; then
        return 0
    fi

    # Check if Homebrew is available
    if ! command -v brew >/dev/null 2>&1; then
        echo
        echo "Homebrew not found. Install dependencies manually:"
        for dep in "${all_missing[@]}"; do
            echo "  brew install $dep"
        done
        return 0
    fi

    # Offer to install missing dependencies
    echo
    local install_deps
    read -e -p "Install missing dependencies with Homebrew? (Y/n): " install_deps
    case "$install_deps" in
        [nN][oO]|[nN])
            echo "Skipped dependency installation."
            ;;
        *)
            echo "Installing dependencies..."
            for dep in "${all_missing[@]}"; do
                echo "  Installing $dep..."
                if brew install "$dep" 2>/dev/null; then
                    echo "  ✓ $dep installed"
                else
                    echo "  ✗ Failed to install $dep"
                fi
            done
            ;;
    esac
}

# Check if gitbash shell integration is set up
check_shell_integration() {
    local shell_rc=""
    local shell_files=("$HOME/.zshrc" "$HOME/.bashrc" "$HOME/.bash_profile")
    
    # Find the first existing shell rc file
    for file in "${shell_files[@]}"; do
        if [[ -f "$file" ]]; then
            shell_rc="$file"
            break
        fi
    done

    if [[ -z "$shell_rc" ]]; then
        echo
        echo "No shell config file found (.zshrc, .bashrc, .bash_profile)"
        return 0
    fi

    # Check if gitbash integration already exists
    local has_init=false
    local has_alias=false

    if grep -q 'eval.*gitbash --init' "$shell_rc" 2>/dev/null; then
        has_init=true
    fi

    if grep -q 'alias.*gitbash' "$shell_rc" 2>/dev/null; then
        has_alias=true
    fi

    # If neither init nor alias found, offer to add
    if [[ "$has_init" == false && "$has_alias" == false ]]; then
        echo
        echo "Shell integration not found in $shell_rc"
        local add_init
        read -e -p "Add 'eval \"\$(gitbash --init)\"' to $shell_rc? (Y/n): " add_init
        case "$add_init" in
            [nN][oO]|[nN])
                echo "Skipped shell integration."
                ;;
            *)
                echo >> "$shell_rc"
                echo '# gitbash shell integration' >> "$shell_rc"
                echo 'eval "$(gitbash --init)"' >> "$shell_rc"
                echo
                echo "Added to $shell_rc"
                echo "Run 'source $shell_rc' or restart your shell to activate."
                ;;
        esac
    else
        echo
        echo "Shell integration already configured in $shell_rc"
    fi
}

# Resolve symlinks to get the actual script location
SOURCE="${BASH_SOURCE[0]}"
while [[ -L "$SOURCE" ]]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ "$SOURCE" != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")/.." && pwd)"

# Export so sourced command files can use it
export SCRIPT_DIR

COMMANDS_DIR="$SCRIPT_DIR/commands"
VERSION="$(grep -o '"version": *"[^"]*"' "$SCRIPT_DIR/package.json" | head -1 | cut -d'"' -f4)"

# Available commands
COMMANDS=(
    "branch"
    "cleanstash"
    "cleanup"
    "commit"
    "commits"
    "create"
    "pr"
    "stale"
    "stash"
    "stashes"
    "status"
    "switch"
    "unstash"
    "update"
)

show_help() {
    cat << 'EOF'
gitbash - Interactive git utilities for bash

Usage:
    gitbash <command> [args...]
    gitbash --help
    gitbash --init
    gitbash --config

Commands:
  branch      Interactive menu for branch operations
  cleanstash  Delete stashes (multi-select)
  cleanup     Find and delete leftover local branches
  commit      Commit with optional push
  commits     List recent commits with revert option
  create      Create feature branch with Jira parsing
  pr          Open PR in browser
  stale       List stale remote branches
  stash       Create named stash
  stashes     Interactive stash menu
  status      Interactive staging with fzf
  switch      Switch branches with fzf
  unstash     Apply stash with fzf picker
  update      Merge latest main/master into current branch

Options:
  -h, --help     Show this help message
  -v, --version  Show version number
  --init         Print shell initialization code (for sourcing)
    --config       Configure gitbash and save to ~/.gitbashrc

Examples:
  gitbash commit fix bug -p     # Commit and push
  gitbash switch feature        # Switch to branch containing "feature"
  gitbash create PROJ-123 fix   # Create feature/PROJ-123-fix

Shell Integration:
  Add to your .bashrc or .bash_profile:
    eval "$(gitbash --init)"

  This enables calling commands directly:
    commit fix bug -p
    switch feature

Dependencies:
  brew install fzf           # Required
  brew install git-delta     # Optional: better diffs
  brew install bat           # Optional: syntax highlighting
EOF
}

show_init() {
    cat << EOF
# gitbash shell integration
# Add this to your .bashrc or .bash_profile:
#   eval "\$(gitbash --init)"

GITBASH_COMMANDS_DIR="$COMMANDS_DIR"

EOF
    # Output source commands for each script
    for cmd in "${COMMANDS[@]}"; do
        if [[ -f "$COMMANDS_DIR/$cmd.sh" ]]; then
            echo "source \"\$GITBASH_COMMANDS_DIR/$cmd.sh\""
        fi
    done
}

# Main entry point
main() {
    load_config
    case "${1:-}" in
        -h|--help|"")
            show_help
            exit 0
            ;;
        -v|--version)
            echo "gitbash $VERSION"
            exit 0
            ;;
        --init)
            show_init
            exit 0
            ;;
        --config)
            configure_gitbash
            exit 0
            ;;
        *)
            local cmd="$1"
            shift
            
            # Check if command exists
            if [[ -f "$COMMANDS_DIR/$cmd.sh" ]]; then
                # Source the command file and execute the function
                source "$COMMANDS_DIR/$cmd.sh"
                "$cmd" "$@"
            else
                echo "Error: Unknown command '$cmd'" >&2
                echo "Run 'gitbash --help' for available commands." >&2
                exit 1
            fi
            ;;
    esac
}

main "$@"


