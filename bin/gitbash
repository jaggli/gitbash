#!/usr/bin/env bash
# gitbash - Interactive git utilities for bash with fzf-powered menus

set -euo pipefail

CONFIG_FILE="$HOME/.gitbashrc"

load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$CONFIG_FILE"
    fi
}

configure_gitbash() {
    load_config

    local current_prefix="${GITBASH_FEATURE_BRANCH_PREFIX:-feature/}"
    local current_merge="${GITBASH_MERGE_COMMAND:-fork}"

    echo "Configure gitbash (writes to $CONFIG_FILE)"
    echo

    local input prefix merge_cmd

    read -e -p "Feature branch prefix (used by create) [${current_prefix}]: " input
    prefix=${input:-$current_prefix}

    read -e -p "Merge tool command (used by update on conflicts) [${current_merge}]: " input
    merge_cmd=${input:-$current_merge}

    cat > "$CONFIG_FILE" <<EOF
# gitbash configuration
# Prefix for feature branches created by 'create'
GITBASH_FEATURE_BRANCH_PREFIX="$prefix"
# Merge tool command invoked by 'update' when conflicts occur
GITBASH_MERGE_COMMAND="$merge_cmd"
EOF

    echo
    echo "Saved configuration to $CONFIG_FILE"

    # Check for dependencies
    check_dependencies

    # Check for shell integration
    check_shell_integration
}

# Check and offer to install dependencies
check_dependencies() {
    local missing_required=()
    local missing_optional=()

    # Required dependencies
    if ! command -v fzf >/dev/null 2>&1; then
        missing_required+=("fzf")
    fi

    # Optional dependencies
    if ! command -v delta >/dev/null 2>&1; then
        missing_optional+=("git-delta")
    fi
    if ! command -v bat >/dev/null 2>&1; then
        missing_optional+=("bat")
    fi

    # If nothing missing, we're done
    if [[ ${#missing_required[@]} -eq 0 && ${#missing_optional[@]} -eq 0 ]]; then
        echo
        echo "All dependencies installed ✓"
        return 0
    fi

    echo
    echo "Dependencies:"

    # Show status of each dependency
    if command -v fzf >/dev/null 2>&1; then
        echo "  ✓ fzf (required)"
    else
        echo "  ✗ fzf (required) - fuzzy finder for interactive selection"
    fi

    if command -v delta >/dev/null 2>&1; then
        echo "  ✓ git-delta (optional)"
    else
        echo "  ✗ git-delta (optional) - better diff highlighting"
    fi

    if command -v bat >/dev/null 2>&1; then
        echo "  ✓ bat (optional)"
    else
        echo "  ✗ bat (optional) - syntax highlighting for file previews"
    fi

    # Build list of all missing dependencies
    local all_missing=()
    [[ ${#missing_required[@]} -gt 0 ]] && all_missing+=("${missing_required[@]}")
    [[ ${#missing_optional[@]} -gt 0 ]] && all_missing+=("${missing_optional[@]}")

    # If nothing to install, we're done
    if [[ ${#all_missing[@]} -eq 0 ]]; then
        return 0
    fi

    # Check if Homebrew is available
    if ! command -v brew >/dev/null 2>&1; then
        echo
        echo "Homebrew not found. Install dependencies manually:"
        for dep in "${all_missing[@]}"; do
            echo "  brew install $dep"
        done
        return 0
    fi

    # Offer to install missing dependencies
    echo
    local install_deps
    read -e -p "Install missing dependencies with Homebrew? (Y/n): " install_deps
    case "$install_deps" in
        [nN][oO]|[nN])
            echo "Skipped dependency installation."
            ;;
        *)
            echo "Installing dependencies..."
            for dep in "${all_missing[@]}"; do
                echo "  Installing $dep..."
                if brew install "$dep" 2>/dev/null; then
                    echo "  ✓ $dep installed"
                else
                    echo "  ✗ Failed to install $dep"
                fi
            done
            ;;
    esac
}

# Check if gitbash shell integration is set up
check_shell_integration() {
    local shell_rc=""
    local shell_files=("$HOME/.zshrc" "$HOME/.bashrc" "$HOME/.bash_profile")
    
    # Find the first existing shell rc file
    for file in "${shell_files[@]}"; do
        if [[ -f "$file" ]]; then
            shell_rc="$file"
            break
        fi
    done

    if [[ -z "$shell_rc" ]]; then
        echo
        echo "No shell config file found (.zshrc, .bashrc, .bash_profile)"
        return 0
    fi

    # Check if gitbash integration already exists
    local has_init=false
    local has_alias=false

    if grep -q 'eval.*gitbash --init' "$shell_rc" 2>/dev/null; then
        has_init=true
    fi

    if grep -q 'alias.*gitbash' "$shell_rc" 2>/dev/null; then
        has_alias=true
    fi

    # If neither init nor alias found, offer to add
    if [[ "$has_init" == false && "$has_alias" == false ]]; then
        echo
        echo "Shell integration not found in $shell_rc"
        local add_init
        read -e -p "Add 'eval \"\$(gitbash --init)\"' to $shell_rc? (Y/n): " add_init
        case "$add_init" in
            [nN][oO]|[nN])
                echo "Skipped shell integration."
                ;;
            *)
                echo >> "$shell_rc"
                echo '# gitbash shell integration' >> "$shell_rc"
                echo 'eval "$(gitbash --init)"' >> "$shell_rc"
                echo
                echo "Added to $shell_rc"
                echo "Run 'source $shell_rc' or restart your shell to activate."
                ;;
        esac
    else
        echo
        echo "Shell integration already configured in $shell_rc"
    fi
}

# Resolve symlinks to get the actual script location
SOURCE="${BASH_SOURCE[0]}"
while [[ -L "$SOURCE" ]]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ "$SOURCE" != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")/.." && pwd)"

COMMANDS_DIR="$SCRIPT_DIR/commands"
VERSION="$(grep -o '"version": *"[^"]*"' "$SCRIPT_DIR/package.json" | cut -d'"' -f4)"

# Available commands
COMMANDS=(
    "branch"
    "cleanstash"
    "cleanup"
    "commit"
    "commits"
    "create"
    "pr"
    "stale"
    "stash"
    "stashes"
    "status"
    "switch"
    "unstash"
    "update"
)

show_help() {
    cat << 'EOF'
gitbash - Interactive git utilities for bash

Usage:
    gitbash <command> [args...]
    gitbash --help
    gitbash --init
    gitbash --config

Commands:
  branch      Interactive menu for branch operations
  cleanstash  Delete stashes (multi-select)
  cleanup     Find and delete leftover local branches
  commit      Commit with optional push
  commits     List recent commits with revert option
  create      Create feature branch with Jira parsing
  pr          Open PR in browser
  stale       List stale remote branches
  stash       Create named stash
  stashes     Interactive stash menu
  status      Interactive staging with fzf
  switch      Switch branches with fzf
  unstash     Apply stash with fzf picker
  update      Merge latest main/master into current branch

Options:
  -h, --help     Show this help message
  -v, --version  Show version number
  --init         Print shell initialization code (for sourcing)
    --config       Configure gitbash and save to ~/.gitbashrc

Examples:
  gitbash commit fix bug -p     # Commit and push
  gitbash switch feature        # Switch to branch containing "feature"
  gitbash create PROJ-123 fix   # Create feature/PROJ-123-fix

Shell Integration:
  Add to your .bashrc or .bash_profile:
    eval "$(gitbash --init)"

  This enables calling commands directly:
    commit fix bug -p
    switch feature

Dependencies:
  brew install fzf           # Required
  brew install git-delta     # Optional: better diffs
  brew install bat           # Optional: syntax highlighting
EOF
}

show_init() {
    cat << EOF
# gitbash shell integration
# Add this to your .bashrc or .bash_profile:
#   eval "\$(gitbash --init)"

GITBASH_COMMANDS_DIR="$COMMANDS_DIR"

EOF
    # Output source commands for each script
    for cmd in "${COMMANDS[@]}"; do
        if [[ -f "$COMMANDS_DIR/$cmd.sh" ]]; then
            echo "source \"\$GITBASH_COMMANDS_DIR/$cmd.sh\""
        fi
    done
}

# Main entry point
main() {
    load_config
    case "${1:-}" in
        -h|--help|"")
            show_help
            exit 0
            ;;
        -v|--version)
            echo "gitbash $VERSION"
            exit 0
            ;;
        --init)
            show_init
            exit 0
            ;;
        --config)
            configure_gitbash
            exit 0
            ;;
        *)
            local cmd="$1"
            shift
            
            # Check if command exists
            if [[ -f "$COMMANDS_DIR/$cmd.sh" ]]; then
                # Source the command file and execute the function
                source "$COMMANDS_DIR/$cmd.sh"
                "$cmd" "$@"
            else
                echo "Error: Unknown command '$cmd'" >&2
                echo "Run 'gitbash --help' for available commands." >&2
                exit 1
            fi
            ;;
    esac
}

main "$@"


